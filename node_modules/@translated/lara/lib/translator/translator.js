"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Translator = exports.Memories = void 0;
const net_1 = __importDefault(require("../net"));
const errors_1 = require("../errors");
class Memories {
    constructor(client) {
        this.client = client;
        this.pollingInterval = 2000;
    }
    async list() {
        return await this.client.get("/memories");
    }
    async create(name, externalId) {
        return await this.client.post("/memories", {
            name, external_id: externalId
        });
    }
    async get(id) {
        try {
            return await this.client.get(`/memories/${id}`);
        }
        catch (e) {
            if (e instanceof errors_1.LaraApiError && e.statusCode === 404) {
                return null;
            }
            throw e;
        }
    }
    async delete(id) {
        return await this.client.delete(`/memories/${id}`);
    }
    async update(id, name) {
        return await this.client.put(`/memories/${id}`, { name });
    }
    async connect(ids) {
        const memories = await this.client.post("/memories/connect", {
            ids: Array.isArray(ids) ? ids : [ids]
        });
        return (Array.isArray(ids) ? memories : memories[0]);
    }
    async importTmx(id, tmx, gzip = false) {
        return await this.client.post(`/memories/${id}/import`, {
            compression: gzip ? 'gzip' : undefined
        }, {
            tmx
        });
    }
    async addTranslation(id, source, target, sentence, translation, tuid, sentenceBefore, sentenceAfter) {
        const body = {
            source,
            target,
            sentence,
            translation,
            tuid,
            sentence_before: sentenceBefore,
            sentence_after: sentenceAfter
        };
        if (Array.isArray(id)) {
            body.ids = id;
            return await this.client.put("/memories/content", body);
        }
        else {
            return await this.client.put(`/memories/${id}/content`, body);
        }
    }
    async deleteTranslation(id, source, target, sentence, translation, tuid, sentenceBefore, sentenceAfter) {
        const body = {
            source,
            target,
            sentence,
            translation,
            tuid,
            sentence_before: sentenceBefore,
            sentence_after: sentenceAfter
        };
        if (Array.isArray(id)) {
            body.ids = id;
            return await this.client.delete("/memories/content", body);
        }
        else {
            return await this.client.delete(`/memories/${id}/content`, body);
        }
    }
    async getImportStatus(id) {
        return await this.client.get(`/memories/imports/${id}`);
    }
    async waitForImport(mImport, updateCallback, maxWaitTime) {
        const start = Date.now();
        while (mImport.progress < 1.) {
            if (maxWaitTime && Date.now() - start > maxWaitTime)
                throw new errors_1.TimeoutError();
            await new Promise(resolve => setTimeout(resolve, this.pollingInterval));
            mImport = await this.getImportStatus(mImport.id);
            if (updateCallback)
                updateCallback(mImport);
        }
        return mImport;
    }
}
exports.Memories = Memories;
class Translator {
    constructor(credentials, options) {
        this.client = (0, net_1.default)(credentials.accessKeyId, credentials.accessKeySecret, options === null || options === void 0 ? void 0 : options.serverUrl);
        this.memories = new Memories(this.client);
    }
    async getLanguages() {
        return await this.client.get("/languages");
    }
    async translate(text, source, target, options) {
        return await this.client.post("/translate", {
            q: text, source, target, source_hint: options === null || options === void 0 ? void 0 : options.sourceHint,
            content_type: options === null || options === void 0 ? void 0 : options.contentType, multiline: (options === null || options === void 0 ? void 0 : options.multiline) !== false,
            adapt_to: options === null || options === void 0 ? void 0 : options.adaptTo, instructions: options === null || options === void 0 ? void 0 : options.instructions,
            timeout: options === null || options === void 0 ? void 0 : options.timeoutInMillis, priority: options === null || options === void 0 ? void 0 : options.priority,
            use_cache: options === null || options === void 0 ? void 0 : options.useCache, cache_ttl: options === null || options === void 0 ? void 0 : options.cacheTTLSeconds
        });
    }
}
exports.Translator = Translator;
